{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TypeSynonymInstances #-}

module Lang.Simp.IR.DF where

import Data.List (nub, sort)
import Data.Map qualified as DM
import Data.Maybe
import Data.Set qualified as DS
import Lang.Simp.IR.CFG
import Lang.Simp.IR.PseudoAssembly

{-
   This module contains the implementation of dominator tree, and dominance  frontier utils
    1. dominator tree
    2. construct a dominator tree from a CFG (generated from a PA program)
    3. construct a dominance frontier table
-}

data DomTree
  = -- | empty tree
    Empty
  | -- | tree with a label and childrens
    Node Label [DomTree]
  deriving (Show, Eq)

{-
        Dominator tree construction algorithm.
        We do not follow the standard naive algorithm nor the semi-dominator tree approach
        The CFGs generated in our context are "structured", i.e.
            1. branches and loops are generated by structured statement such as if-else and while.
            2. there is only one exit point

        Terminology
            1. successor, the next vertex in the graph,
            1. descendant, successor via transitivity
            1. child, the child node in the dominiator tree

        The algorithm starts from vertex 0 which is the starting statement.
        Given vertex n in Graph G,
        case 1: n has only 1 successor m in the CFG
            we create Node(n, List(t)), where t is generated recurssively using m against (G - {n})
        case 2: n has 2 successors m and k, m and k share some common nearest descendant j in (G - {n})
            (given two common descendant, j and l, j is nearer than l if j < l,
                since we generate the labels by following the sequential structure of the program)
            we create Node(n, List(s,t))
                where s is generated recursively using m against (G - {n, j})
                and t is generated recursively using k against (G - {n, j})
            this case is to handle the structure generated by if-else
                n
                /\
               m  k
               |  |
                \/
                j
        case 3: n has 2 successor m and k, m and k share no common descendant in (G - {n})
             ->n
            / / \
           | m   k
           | |
           \ /
           we create Node(n, List(s,t))
              where s is generated recursively using m against (G - {n})
              and t is generated recursively using k against (G - {n})
          Note that it is not possible for k to loop back to n as n is removed from G when constructing t.
        case 4: n has no successor, return Node(n, Nil)

        What about other case where n has more than 2 successors?
        not possible, our maximal munch algo guarantees there is an ending vertex
        for each block (as the endThen and endElse goto)
-}

-- | remove a vertex v from the graph g
remove :: CFG -> Label -> CFG
remove g v =
  let g' = DM.delete v g
   in DM.map (filter (/= v)) g'

buildDomTree :: CFG -> Label -> Either String DomTree
buildDomTree g n = case successors g n of
  [] -> Right (Node n []) -- case 4
  [m] -> do
    -- case 1
    t <- buildDomTree (remove g n) m
    return (Node n [t])
  [m, k] ->
    let g1 = remove g n
        descM = descendants g1 m
        descK = descendants g1 k
        common = descM `DS.intersection` descK -- possible optimization, we only need the first one.
     in case sort (DS.toList common) of
          j : xs ->
            -- case 2
            let g2 = remove g1 j
             in do
                  s <- buildDomTree g2 m
                  t <- buildDomTree g2 k
                  return (Node n [s, t])
          [] -> do
            -- case 3
            s <- buildDomTree g1 m
            t <- buildDomTree g1 k
            return (Node n [s, t])
  _ -> Left ("buildDomTree failed. There are 3 successors for label " ++ show n ++ ".")

-- | returns the list of labels of x's children in dom tree dt
childOf :: Label -> DomTree -> [Label]
childOf x Empty = []
childOf x (Node l children)
  | l == x =
      concatMap
        ( \t -> case t of
            Node m _ -> [m]
            Empty -> []
        )
        children
  | otherwise = foldl (\acc ch -> acc ++ childOf x ch) [] children

-- | checks whether label y is a immediate child of x in dom tree dt
isChildOf :: Label -> Label -> DomTree -> Bool
isChildOf y x dt = y `elem` childOf x dt

type DFTable = DM.Map Label [Label] -- mapping label to its dominance frontiers

{-
1. For each vertex v by traversing the dominator tree bottom up:
    i. compute df_local(v, G)
    ii. compute U_u\inchild(v,T) df_up(u,G), which can be looked up from the a memoization table.
    iii. save df(v,G)=dflocal(v,G) union U_u\in child(v,T) in the memoizationtable.
-}

-- | post order traversal of a dom tree is in-order traversal then reverse
postOrderTrav :: DomTree -> [Label]
postOrderTrav = reverse . inOrderTrav

-- | inorder traversal of a dom tree.
inOrderTrav :: DomTree -> [Label]
inOrderTrav Empty = []
inOrderTrav (Node v children) = v : concatMap inOrderTrav children

-- | df local implementation from cytron's lemma 2
-- | Lab 3 Task 1.1 TODO
dfLocal :: Label -> DomTree -> CFG -> [Label]
dfLocal = undefined -- fixme

-- | Build Dominance frontier table
buildDFT :: DomTree -> CFG -> DFTable
buildDFT dt g = foldl go DM.empty (postOrderTrav dt)
  where
    go :: DFTable -> Label -> DFTable
    go acc x =
      let local = dfLocal x dt g
          -- Lab 3 Task 1.1. TODO
          dfUp :: Label -> [Label]
          dfUp = undefined -- fixme
          up = concatMap dfUp (childOf x dt)
       in DM.insert x (sort (local ++ up)) acc

-- Lab 3 Task 1.1 end

dfPlus :: DFTable -> Label -> [Label]
dfPlus = dfp

-- | computing DF+
class DFP a where
  dfp :: DFTable -> a -> [Label]

instance DFP Label where
  dfp dft v = dfp dft [v]

instance DFP [Label] where
  dfp dft vs = go (nub (sort vs))
    where
      go :: [Label] -> [Label]
      go curr =
        let next = nub (sort (df dft curr))
         in if next == curr
              then curr
              else go next

-- | look up the set of DFs from a list of vertices.
df :: DFTable -> [Label] -> [Label]
df dft = concatMap go
  where
    go v = Data.Maybe.fromMaybe [] (DM.lookup v dft)