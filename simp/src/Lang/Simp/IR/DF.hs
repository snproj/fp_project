{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE FlexibleInstances #-}
module Lang.Simp.IR.DF where

import Data.Maybe
import qualified Data.Map as DM
import qualified Data.Set as DS
import Data.List (sort, nub)
import Lang.Simp.IR.CFG
import Lang.Simp.IR.PseudoAssembly


{-
   This module contains the implementation of dominator tree, and dominance  frontier utils
    1. dominator tree
    2. construct a dominator tree from a CFG (generated from a PA program)
    3. construct a dominance frontier table
-}


data DomTree = Empty       -- ^ empty tree
    | Node Label [DomTree] -- ^ tree with a label and childrens
    deriving (Show,Eq)


{-
        Dominator tree construction algorithm.
        We do not follow the standard naive algorithm nor the semi-dominator tree approach
        The CFGs generated in our context are "structured", i.e. 
            1. branches and loops are generated by structured statement such as if-else and while. 
            2. there is only one exit point

        Terminology 
            1. successor, the next vertex in the graph,
            1. descendant, successor via transitivity
            1. child, the child node in the dominiator tree 


        The algorithm starts from vertex 0 which is the starting statement.
        Given vertex n in Graph G, 
        case 1: n has only 1 successor m in the CFG
            we create Node(n, List(t)), where t is generated recurssively using m against (G - {n})
        case 2: n has 2 successors m and k, m and k share some common nearest descendant j in (G - {n})
            (given two common descendant, j and l, j is nearer than l if j < l, 
                since we generate the labels by following the sequential structure of the program)
            we create Node(n, List(s,t)) 
                where s is generated recursively using m against (G - {n, j})
                and t is generated recursively using k against (G - {n, j})
            this case is to handle the structure generated by if-else
                n 
                /\
               m  k
               |  |
                \/
                j
        case 3: n has 2 successor m and k, m and k share no common descendant in (G - {n})
             ->n
            / / \
           | m   k
           | |
           \ / 
           we create Node(n, List(s,t)) 
              where s is generated recursively using m against (G - {n})
              and t is generated recursively using k against (G - {n})
          Note that it is not possible for k to loop back to n as n is removed from G when constructing t.
        case 4: n has no successor, return Node(n, Nil)
        
        What about other case where n has more than 2 successors? 
        not possible, our maximal munch algo guarantees there is an ending vertex 
        for each block (as the endThen and endElse goto)
-}

-- | remove a vertex v from the graph g
remove :: CFG -> Label -> CFG
remove g v =
    let g' = DM.delete v g
    in DM.map (filter (/= v)) g'

buildDomTree :: CFG -> Label -> Either String DomTree
buildDomTree g n = case successors g n  of
    []    -> Right (Node n []) -- case 4 
    [m]   -> do -- case 1
        t <- buildDomTree (remove g n) m
        return (Node n [t])
    [m,k] ->
        let g1 = remove g n
            descM  = descendants g1 m
            descK  = descendants g1 k
            common = descM `DS.intersection` descK -- possible optimization, we only need the first one.
        in case sort (DS.toList common) of
            j:xs -> -- case 2
                let g2 = remove g1 j
                in do
                    s <- buildDomTree g2 m
                    t <- buildDomTree g2 k
                    return (Node n [s,t])
            []   -> do -- case 3 
                    s <- buildDomTree g1 m 
                    t <- buildDomTree g1 k 
                    return (Node n [s,t])                
    _    -> Left ("buildDomTree failed. There are 3 successors for label " ++ show n ++ ".")


-- | returns the list of labels of x's children in dom tree dt
childOf :: Label -> DomTree -> [Label]
childOf x Empty = []
childOf x (Node l children)
    | l == x    = concatMap (\t -> case t of
                                { Node m _ -> [m]
                                ; Empty    -> []}) children
    | otherwise = foldl (\ acc ch -> acc ++ childOf x ch) [] children

-- | checks whether label y is a immediate child of x in dom tree dt
isChildOf :: Label -> Label -> DomTree -> Bool
isChildOf y x dt = y `elem` childOf x dt

type DFTable = DM.Map Label [Label] -- mapping label to its dominance frontiers


{-
1. For each vertex v by traversing the dominator tree bottom up: 
    i. compute df_local(v, G)
    ii. compute U_u\inchild(v,T) df_up(u,G), which can be looked up from the a memoization table. 
    iii. save df(v,G)=dflocal(v,G) union U_u\in child(v,T) in the memoizationtable.
-}


-- | post order traversal of a dom tree is in-order traversal then reverse
postOrderTrav :: DomTree -> [Label]
postOrderTrav = reverse . inOrderTrav


-- | inorder traversal of a dom tree. 
inOrderTrav :: DomTree -> [Label]
inOrderTrav Empty = []
inOrderTrav (Node v children) = v : concatMap inOrderTrav children


-- | df local implementation from cytron's lemma 2
-- | Lab 3 Task 1.1 TODO 
dfLocal :: Label -> DomTree -> CFG -> [Label]
dfLocal = undefined -- fixme

-- | Build Dominance frontier table
buildDFT :: DomTree -> CFG -> DFTable
buildDFT dt g = foldl go DM.empty (postOrderTrav dt)
    where
        go :: DFTable -> Label -> DFTable
        go acc x =
            let local  = dfLocal x dt g
                -- Lab 3 Task 1.1. TODO
                dfUp :: Label -> [Label]
                dfUp = undefined -- fixme
                up     = concatMap dfUp (childOf x dt)
            in  DM.insert x (sort (local ++ up)) acc
-- Lab 3 Task 1.1 end 

dfPlus :: DFTable -> Label -> [Label]
dfPlus = dfp


-- | computing DF+
class DFP a where
    dfp :: DFTable -> a -> [Label]


instance DFP Label where
    dfp dft v = dfp dft [v]


instance DFP [Label] where
    dfp dft vs = go (nub (sort vs))
        where
            go :: [Label] -> [Label]
            go curr =
                let next = nub (sort (df dft curr))
                in if next == curr
                    then curr
                    else go next

-- | look up the set of DFs from a list of vertices.
df :: DFTable -> [Label] -> [Label]
df dft = concatMap go
    where
        go v = Data.Maybe.fromMaybe [] (DM.lookup v dft)